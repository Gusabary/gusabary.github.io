<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>C++17 STL Cookbook Notes | Gusabary</title><meta name="description" content="C++17 STL Cookbook Notes"><meta name="keywords" content="C++,C++17 STL Cookbook"><meta name="author" content="Gusabary"><meta name="copyright" content="Gusabary"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="C++17 STL Cookbook Notes"><meta name="twitter:description" content="C++17 STL Cookbook Notes"><meta name="twitter:image" content="http://gusabary.cn/covers/12.jpg"><meta property="og:type" content="article"><meta property="og:title" content="C++17 STL Cookbook Notes"><meta property="og:url" content="http://gusabary.cn/2021/03/22/C++17-STL-Cookbook/"><meta property="og:site_name" content="Gusabary"><meta property="og:description" content="C++17 STL Cookbook Notes"><meta property="og:image" content="http://gusabary.cn/covers/12.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://gusabary.cn/2021/03/22/C++17-STL-Cookbook/"><link rel="next" title="Modern C++ Programming Cookbook Notes 7: Stream, Robustness and Idioms" href="http://gusabary.cn/2020/11/22/Modern-C++-Programming-Cookbook-Notes/Modern-C++-Programming-Cookbook-Notes-7/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Gusabary</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">13</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-1-The-New-C-17-Features"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Chapter 1  The New C++17 Features</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-structured-bindings"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1.1  structured bindings</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-if-and-switch-with-initializers"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">1.2  if and switch with initializers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-bracket-initializer-with-auto"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">1.3  bracket initializer with auto</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-class-template-argument-deduction-CTAD"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">1.4  class template argument deduction (CTAD)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5-constexpr-if"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">1.5  constexpr if</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-6-inline-variables"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">1.6  inline variables</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-7-fold-expressions"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">1.7  fold expressions</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-2-STL-Containers"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Chapter 2  STL Containers</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-3-Iterators"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">Chapter 3  Iterators</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-4-Lambda-Expressions"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">Chapter 4  Lambda Expressions</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-5-STL-Algorithm-Basics"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Chapter 5  STL Algorithm Basics</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-6-Advanced-Use-of-STL-Algorithms"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text">Chapter 6  Advanced Use of STL Algorithms</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-7-Strings-Stream-Classes-and-Regular-Expressions"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text">Chapter 7  Strings, Stream Classes, and Regular Expressions</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-8-Utility-Classes"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text">Chapter 8  Utility Classes</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-9-Parallelism-and-Concurrency"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text">Chapter 9  Parallelism and Concurrency</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-10-Filesystem"><span class="toc_mobile_items-number">10.</span> <span class="toc_mobile_items-text">Chapter 10  Filesystem</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Link"><span class="toc_mobile_items-number">11.</span> <span class="toc_mobile_items-text">Link</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-1-The-New-C-17-Features"><span class="toc-number">1.</span> <span class="toc-text">Chapter 1  The New C++17 Features</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-structured-bindings"><span class="toc-number">1.1.</span> <span class="toc-text">1.1  structured bindings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-if-and-switch-with-initializers"><span class="toc-number">1.2.</span> <span class="toc-text">1.2  if and switch with initializers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-bracket-initializer-with-auto"><span class="toc-number">1.3.</span> <span class="toc-text">1.3  bracket initializer with auto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-class-template-argument-deduction-CTAD"><span class="toc-number">1.4.</span> <span class="toc-text">1.4  class template argument deduction (CTAD)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-constexpr-if"><span class="toc-number">1.5.</span> <span class="toc-text">1.5  constexpr if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-inline-variables"><span class="toc-number">1.6.</span> <span class="toc-text">1.6  inline variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-fold-expressions"><span class="toc-number">1.7.</span> <span class="toc-text">1.7  fold expressions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-STL-Containers"><span class="toc-number">2.</span> <span class="toc-text">Chapter 2  STL Containers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3-Iterators"><span class="toc-number">3.</span> <span class="toc-text">Chapter 3  Iterators</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-4-Lambda-Expressions"><span class="toc-number">4.</span> <span class="toc-text">Chapter 4  Lambda Expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-STL-Algorithm-Basics"><span class="toc-number">5.</span> <span class="toc-text">Chapter 5  STL Algorithm Basics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-6-Advanced-Use-of-STL-Algorithms"><span class="toc-number">6.</span> <span class="toc-text">Chapter 6  Advanced Use of STL Algorithms</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-7-Strings-Stream-Classes-and-Regular-Expressions"><span class="toc-number">7.</span> <span class="toc-text">Chapter 7  Strings, Stream Classes, and Regular Expressions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-8-Utility-Classes"><span class="toc-number">8.</span> <span class="toc-text">Chapter 8  Utility Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-9-Parallelism-and-Concurrency"><span class="toc-number">9.</span> <span class="toc-text">Chapter 9  Parallelism and Concurrency</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-10-Filesystem"><span class="toc-number">10.</span> <span class="toc-text">Chapter 10  Filesystem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Link"><span class="toc-number">11.</span> <span class="toc-text">Link</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/covers/12.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">C++17 STL Cookbook Notes</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2021-03-22<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2021-03-22</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="Chapter-1-The-New-C-17-Features"><a href="#Chapter-1-The-New-C-17-Features" class="headerlink" title="Chapter 1  The New C++17 Features"></a>Chapter 1  The New C++17 Features</h2><h3 id="1-1-structured-bindings"><a href="#1-1-structured-bindings" class="headerlink" title="1.1  structured bindings"></a>1.1  structured bindings</h3><ul>
<li>Structured bindings can be used to unpack pair, tuple, <strong>struct</strong> and even <strong>array of fixed size</strong>.</li>
<li>Before C++17, there is a <code>std::tie</code> which has similar functionality. What’s more, combined with <code>std::tie</code>, we can use <code>std::ignore</code> to represent a placeholder for uninterested field.</li>
</ul>
<h3 id="1-2-if-and-switch-with-initializers"><a href="#1-2-if-and-switch-with-initializers" class="headerlink" title="1.2  if and switch with initializers"></a>1.2  if and switch with initializers</h3><ul>
<li><p>Define variables which will only be used in if scope in the if-initializer:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> it = m.<span class="built_in">find</span>(c); it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// it is not available now</span></span><br></pre></td></tr></table></figure></div>

<p>the same with switch statement.</p>
</li>
<li><p>Essentially, it’s just a syntactic sugar of</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (it != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="1-3-bracket-initializer-with-auto"><a href="#1-3-bracket-initializer-with-auto" class="headerlink" title="1.3  bracket initializer with auto"></a>1.3  bracket initializer with auto</h3><ul>
<li>When using bracket initializer to initialize an auto object, here comes the rule:<ul>
<li><code>auto var {arg}</code> deduces <code>var</code> to be the same type with <code>arg</code></li>
<li><code>auto var {arg1, arg2, ...}</code> is invalid and doesn’t compile</li>
<li><code>auto var = {arg1, arg2, ...}</code> deduces <code>var</code> to be <code>std::initializer_list&lt;T&gt;</code> if all <code>args</code> have the type <code>T</code>.</li>
</ul>
</li>
</ul>
<h3 id="1-4-class-template-argument-deduction-CTAD"><a href="#1-4-class-template-argument-deduction-CTAD" class="headerlink" title="1.4  class template argument deduction (CTAD)"></a>1.4  class template argument deduction (CTAD)</h3><ul>
<li><p>With CTAD, we can define a class template without specifying template arguments if the constructor arguments can help deduce them:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::pair <span class="title">my_pair</span> <span class="params">(<span class="number">123</span>, <span class="string">"abc"</span>)</span></span>;       <span class="comment">// std::pair&lt;int, const char*&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Actually compiler has implicit deduction guides, which sometimes cannot satisfy our requirement:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sum</span> &#123;</span></span><br><span class="line">    T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line">    sum(Ts&amp;&amp; ... values) : value&#123;(values + ...)&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">sum s &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure></div>

<p>Compiler cannot deduce <code>T</code> from argument list <code>Ts: int, int, int, int</code>, so we need a <strong>explicit deduction guide</strong>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line">sum(Ts&amp;&amp; ... ts) -&gt; sum&lt;<span class="built_in">std</span>::<span class="keyword">common_type_t</span>&lt;Ts...&gt;&gt;;</span><br></pre></td></tr></table></figure></div>

<p>to help compiler perform the deduction.</p>
</li>
<li><p><em>(reference)[<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction]" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/class_template_argument_deduction]</a></em></p>
</li>
</ul>
<h3 id="1-5-constexpr-if"><a href="#1-5-constexpr-if" class="headerlink" title="1.5  constexpr if"></a>1.5  constexpr if</h3><ul>
<li>Different from <code>#if</code>, all branches in constexpr if have to be <strong>syntactically well-formed</strong> (but not necessarily <strong>semantically valid</strong>).</li>
</ul>
<h3 id="1-6-inline-variables"><a href="#1-6-inline-variables" class="headerlink" title="1.6  inline variables"></a>1.6  inline variables</h3><ul>
<li><p>Declare variables as inline to avoid multiple definition error during link stage:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process_monitor</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> standard_string </span><br><span class="line">        &#123;<span class="string">"some static globally available string"</span>&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> process_monitor global_process_monitor;</span><br></pre></td></tr></table></figure></div>

<p>which makes it easier to develop header-only library.</p>
</li>
</ul>
<h3 id="1-7-fold-expressions"><a href="#1-7-fold-expressions" class="headerlink" title="1.7  fold expressions"></a>1.7  fold expressions</h3><ul>
<li><p>Use fold expressions to calculate on arguments of variadic template in a single line of code.</p>
</li>
<li><p>Note that fold expressions can not only work on arguments pack itself, but also expression including the pack:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insert_all</span><span class="params">(T &amp;<span class="built_in">set</span>, Ts ... ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">set</span>.insert(ts).second &amp;&amp; ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>In another word, it can be considered that because <code>ts</code> is a pack, the whole <code>set.insert(ts).second</code> also becomes a pack.</p>
</li>
</ul>
<h2 id="Chapter-2-STL-Containers"><a href="#Chapter-2-STL-Containers" class="headerlink" title="Chapter 2  STL Containers"></a>Chapter 2  STL Containers</h2><ul>
<li><p><strong>erase-remove idiom</strong>: <code>std::remove</code> just move around elements in the container and return the <strong>new end iterator</strong> so we need to invoke <code>erase</code> method again to erase in fact those elements after the new end iterator:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.erase(remove_if(<span class="built_in">begin</span>(v), <span class="built_in">end</span>(v), odd), <span class="built_in">end</span>(v));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>if the order of a vector doesn’t matter, when deleting an item by index or iterator, we can overwrite it with the last item and then erase the last one, so the deletion is O(1)</p>
</li>
<li><p>compared to <code>operator[]</code>, we can use <code>at</code> method to perform bound check, and the price is a negligible performance loss.</p>
</li>
<li><p>use <code>lower_bound</code> to get the right position for a new item in a sorted container and then perform insertion to keep it always sorted</p>
</li>
<li><p>after C++17, we can use <code>try_emplace</code> method of map to <strong>try</strong> inserting an entry into a map, that’s to say, if the key exists, the inserted object won’t be constructed, which saves really much time for us, compared to old <code>insert</code> and <code>emplace</code>.</p>
</li>
<li><p><code>insert</code> method of map provides an overload which takes an iterator as a hint to denote the position where the inserted item should be. If the hint is correct (this can be easily checked through whether the newly inserted item and the hint is direct neighbor), insertion performance can be improved.</p>
</li>
<li><p>it’s a fact that type of key in a map is const, so we cannot directly change it. However, after C++17, map supports <code>extract</code> method to extract (remove and get) a node from map, whose <code>key</code> method returns a non-const reference to key of the node. so we can modify that and then reinsert it to map without any performance penalty (especially heap allocation)</p>
</li>
<li><p>actually <code>std::unordered_map</code>‘s complete definition is:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Key</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">T</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">Hash</span>      = <span class="title">std</span>:</span>:hash&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">KeyEqual</span>  = <span class="title">std</span>:</span>:equal_to&lt;Key&gt;,</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> = <span class="title">std</span>:</span>:allocator&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Key, T&gt; &gt;</span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">unordered_map</span>;</span></span><br></pre></td></tr></table></figure></div>

<p>if <code>Key</code> is a custom type, we can provide <code>Hash</code> in two ways:</p>
<ul>
<li>specialize <code>std::hash</code> for our type</li>
<li>specify <code>Hash</code> template parameter explicitly</li>
</ul>
</li>
<li><p><code>std::istream_iterator</code> takes a template parameter as token type and a <code>std::istream</code> as the source stream. it supports two operations: 1) <code>*it</code> to get the current token from the stream (equivalent to <code>cin &gt;&gt;</code>) and 2) <code>++it</code> to jump to next token.</p>
<p><code>std::insert_iterator</code> performs kinda like iterator but when assigning value to the element it points to, it <em>inserts</em> a new value.  use <code>std::inserter</code> to get a <code>std::insert_iterator</code>, it takes two arguments: the container and the iterator pointing to where the new element should be inserted.</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; s;</span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; it &#123;<span class="built_in">cin</span>&#125;;</span><br><span class="line">istream_iterator&lt;<span class="built_in">string</span>&gt; <span class="built_in">end</span>;</span><br><span class="line">copy(it, <span class="built_in">end</span>, inserter(s, s.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>move entries in a map into a vector for sorting by value instead of key:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt; words;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;&gt; word_counts;</span><br><span class="line">word_counts.reserve(words.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">move</span>(<span class="built_in">begin</span>(words), <span class="built_in">end</span>(words), back_inserter(word_counts));</span><br></pre></td></tr></table></figure></div>

<p>use <code>back_inserter</code> here because <code>std::vector</code> has only <code>push_back</code> but no <code>push_front</code>.</p>
</li>
<li><p><code>std::priority_queue</code> is also an container adapter, which wraps on <code>std::vector</code> by default. and priority queue is logically implemented by heap.</p>
</li>
</ul>
<h2 id="Chapter-3-Iterators"><a href="#Chapter-3-Iterators" class="headerlink" title="Chapter 3  Iterators"></a>Chapter 3  Iterators</h2><ul>
<li><p>it’s recommended to declare constructor which create a type from another type as explicit to avoid implicit type conversion.</p>
</li>
<li><p>to make our own iterators compatible with STL algorithm, we need to activate <strong>iterator trait</strong> functionality for it, i.e. specialize <code>std::iterator_traits</code> for our own iterator class and populate some type definitions like <code>iterator_category</code>, <code>value_type</code> and so on.</p>
</li>
<li><p>something like <code>std::insert_iterator</code> and <code>std::istream_iterator</code> is called <strong>iterator adapter</strong>, it can wrap an object into an iterator which can perform some special operation on the object when dereferenced, assigned, increased or whatever.</p>
</li>
<li><p>use <code>std::make_reverse_iterator</code> to get <code>rbegin</code> from <code>end</code>.</p>
</li>
<li><p>since C++17, there is no constraint that <code>begin</code> and <code>end</code> iterator should be the same type in range-based loop syntactic sugar, so we can use a <strong>iterator sentinel</strong> as end iterator when it’s not that easy to determine a real end iterator.</p>
</li>
<li><p>gcc (and clang) provides some sanitizers to check whether STL iterators are correctly used. enable these sanitizers by passing some flags during compilation.</p>
</li>
<li><p><code>std::valarray</code> (since C++98) supports element-wise mathematical operations.</p>
<p>range in C++20 can make cpp code more function-programming like.</p>
</li>
</ul>
<h2 id="Chapter-4-Lambda-Expressions"><a href="#Chapter-4-Lambda-Expressions" class="headerlink" title="Chapter 4  Lambda Expressions"></a>Chapter 4  Lambda Expressions</h2><ul>
<li><p>since C++14, we can initialize new variables in the capture list like this:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[count = <span class="number">0</span>] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++count; &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>lambda without capturing any variable has the same (more precisely, not the complete same, just convertible) type with corresponding function pointer, but those which has non-empty capture list cannot be represented by function pointer:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">void</span> (*)(<span class="keyword">int</span>)&gt; v;</span><br><span class="line">v.push_back([](<span class="keyword">int</span>) &#123;&#125;);    <span class="comment">// ok</span></span><br><span class="line">v.push_back([a](<span class="keyword">int</span>) &#123;&#125;);   <span class="comment">// error</span></span><br></pre></td></tr></table></figure></div>

<p>so <code>std::function</code> comes into play.</p>
</li>
<li><p>std library has provided some logical conjunction functor for us like <code>std::logical_and&lt;&gt;</code>.</p>
</li>
</ul>
<h2 id="Chapter-5-STL-Algorithm-Basics"><a href="#Chapter-5-STL-Algorithm-Basics" class="headerlink" title="Chapter 5  STL Algorithm Basics"></a>Chapter 5  STL Algorithm Basics</h2><ul>
<li><p>by default, <code>std::is_sorted</code> will return false for vector with descending elements like 3, 2, 1.</p>
</li>
<li><p>we can provide comparison function whose signature has form like <code>bool(const T&amp;, const T&amp;)</code> as the third argument of <code>sort</code> algorithm. note that this function shouldn’t have any side effect.</p>
</li>
<li><p><code>std::remove</code> and <code>std::replace</code> algorithms have their <code>_copy</code> counterpart which leave the source container unaltered.</p>
</li>
<li><p><code>std::copy</code> and <code>std::transform</code> could have source iterator and destination one of different types. e.g. copy elements to stdout:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy(<span class="built_in">begin</span>(vs), <span class="built_in">end</span>(vs), ostream_iterator&lt;<span class="built_in">string</span>&gt;&#123;<span class="built_in">cout</span>, <span class="string">"\n"</span>&#125;);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>std::binary_search</code> and <code>std::equal_range</code> (also <code>std::lower_bound</code> and <code>std::upper_bound</code>) use binary search on the container so the elements are required to be sorted.</p>
</li>
<li><p><code>std::minmax_element</code> and <code>std::clamp</code> can be useful.</p>
</li>
<li><p>since C++17, we can provide <strong>searcher</strong> for <code>std::search</code> algorithm, which might bring some performance improvement.</p>
</li>
<li><p>C++17 provides a <code>std::sample</code> to sample limited number of elements from a long container.</p>
</li>
</ul>
<h2 id="Chapter-6-Advanced-Use-of-STL-Algorithms"><a href="#Chapter-6-Advanced-Use-of-STL-Algorithms" class="headerlink" title="Chapter 6  Advanced Use of STL Algorithms"></a>Chapter 6  Advanced Use of STL Algorithms</h2><ul>
<li><code>logical_not</code> just negates a variable (i.e. <code>!var</code>) while <code>not_fn</code> creates a new function whose return value is always reversed compared to the original function. in a word, these two are completely different.</li>
<li><code>std::unique</code> <strong>remove</strong> repetitive adjacent elements in a container by default, note that a <strong><em>erase-remove</em> idiom</strong> is needed when invoking <code>std::unique</code>.</li>
</ul>
<h2 id="Chapter-7-Strings-Stream-Classes-and-Regular-Expressions"><a href="#Chapter-7-Strings-Stream-Classes-and-Regular-Expressions" class="headerlink" title="Chapter 7  Strings, Stream Classes, and Regular Expressions"></a>Chapter 7  Strings, Stream Classes, and Regular Expressions</h2><ul>
<li><p><code>std::basic_*stream</code>s are templates that can be specialized for different character types and <code>std::*stream</code>s are those specialized for <code>char</code> </p>
</li>
<li><p><code>iostream</code> inherits from <code>istream</code> and <code>ostream</code>, so it combines both input and output capabilities.</p>
</li>
<li><p>there are two ways to initialize a string:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a &#123; <span class="string">"a"</span>  &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>   <span class="title">b</span> <span class="params">( <span class="string">"b"</span>s )</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>note that the former C-style one embeds the string literal in the binary and then copy it to construct a string while the latter creates a string on the fly.</p>
</li>
<li><p>in order to <strong>reference</strong> the underlying string instead of copying, we can use <code>string_view</code>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string_view c &#123; <span class="string">"c"</span>   &#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span>        <span class="title">d</span> <span class="params">( <span class="string">"d"</span>sv )</span></span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>we cannot assume <code>string_view</code> is null-terminated.</p>
</li>
<li><p><code>std::string::npos</code> is equal to <code>size_t(-1)</code>, which is a very large number</p>
</li>
<li><p>use <code>s &gt;&gt; std::ws</code> to filter out the leading whitespaces when reading a stream</p>
</li>
<li><p><code>cin &gt;&gt; x</code>‘s result can be converted into a bool value which indicates whether the reading is successful, if not, we can use <code>cin.clear()</code> and <code>cin.ignore()</code> methods to recover <code>cin</code> to normal working state.</p>
</li>
<li><p>stream object has an internal buffer which can be accessed and altered with <code>rdbuf()</code> method.</p>
</li>
<li><p>actually <code>basic_string</code> has three template parameters: the first is character type, the second is <strong>char_traits</strong> and the third is allocator. char_traits determines some behavior of the string, e.g. how the strings copy or compare. so we can inherit from <code>std::char_traits</code> and customize our own string type.</p>
</li>
<li><p>stream format flags (affected by manipulator) can be accessed and altered with <code>flags()</code> method</p>
</li>
</ul>
<h2 id="Chapter-8-Utility-Classes"><a href="#Chapter-8-Utility-Classes" class="headerlink" title="Chapter 8  Utility Classes"></a>Chapter 8  Utility Classes</h2><ul>
<li><p>C++17’s structural binding (for unpack tuple) is very useful though, we can use <code>std::apply</code> to not only unpack a tuple easily but then invoke a callable with the variables just unpacked automatically.</p>
</li>
<li><p>we can provide a custom deleter for <code>unique_ptr</code> and <code>shared_ptr</code>. however for <code>unique_ptr</code>, this will change its type because the deleter type is the second template parameter of <code>unique_ptr</code> while for <code>shared_ptr</code> it’s not the case: <code>shared_ptr</code>s with different deleters still share the same type, that’s because <code>shared_ptr</code> hides this information in the control block. while <code>unique_ptr</code> promises to be overhead free at runtime so it has no such control block.</p>
</li>
<li><p>we can event create a <code>shared_ptr</code> pointing to a member instead of the entire object:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sperson</span> <span class="params">(make_shared&lt;person&gt;(<span class="string">"John Doe"</span>, <span class="number">30</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sname</span>   <span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt;(sperson, &amp;sperson-&gt;name))</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>in such case, <code>sname</code> also contributes to the reference counter of the <code>*sperson</code> object.</p>
</li>
<li><p>to generate a random value, we first need to construct a random number generator (engine), and then just call it as a callable. At the most time, <code>std::default_random_engine</code> is enough.</p>
</li>
<li><p>to get a series of data shaped by some distributions, we can first construct a distribution and then invoke it with a random number engine to get a shaped value.</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> distro = uniform_int_distribution&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">9</span>&#125;;</span><br><span class="line">default_random_engine e;  <span class="comment">// can seed the engine here also, e.g. e&#123;random_device&#123;&#125;()&#125;;</span></span><br><span class="line"><span class="keyword">auto</span> randome_value = distro(e);</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h2 id="Chapter-9-Parallelism-and-Concurrency"><a href="#Chapter-9-Parallelism-and-Concurrency" class="headerlink" title="Chapter 9  Parallelism and Concurrency"></a>Chapter 9  Parallelism and Concurrency</h2><ul>
<li>since C++17, some STL algorithms add an overload which takes an execution policy as the first parameter. there are three policies in <code>std::execution</code> namespace: <code>sequenced_policy</code>, <code>parallel_policy</code> and <code>parallel_unsequenced_policy</code>. the first two is easy to understand while the third one allows for vectorization, which is kinda like loop unrolling.</li>
<li>use <code>time</code> command to measure how long a binary ran for.</li>
<li>when it comes to modern C++ locking, there are two kinds of classes: <code>mutex</code> and <code>lock</code> (<code>lock_guard&lt;mutex&gt;</code>, the simplest).</li>
<li><code>scoped_lock</code> can take multiple mutexes in its constructor, which could be used to avoid deadlock.</li>
<li>use <code>std::call_once</code> to ensure that a specific function will only be executed once.</li>
<li>when using <code>std::async</code> with <code>std::launch::async</code> policy, note that the returned <code>future</code> from <code>async</code> call will block at its destructor, so if you write something like <code>async(launch::async, f)</code> without save its value, it will actually block here until execution of <code>f</code> completes.</li>
</ul>
<h2 id="Chapter-10-Filesystem"><a href="#Chapter-10-Filesystem" class="headerlink" title="Chapter 10  Filesystem"></a>Chapter 10  Filesystem</h2><ul>
<li><p>with C++17 filesystem library, traverse a directory is extremely simple:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> directory_entry &amp;e : directory_iterator&#123;dir&#125;) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>instead, use <code>recursive_directory_iterator</code> to traverse recursively to subdirectories.</p>
</li>
</ul>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul>
<li><a href="https://subscription.packtpub.com/book/application_development/9781787120495" target="_blank" rel="noopener">https://subscription.packtpub.com/book/application_development/9781787120495</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Gusabary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://gusabary.cn/2021/03/22/C++17-STL-Cookbook/">http://gusabary.cn/2021/03/22/C++17-STL-Cookbook/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++    </a><a class="post-meta__tags" href="/tags/C-17-STL-Cookbook/">C++17 STL Cookbook    </a></div><div class="post_share"><div class="social-share" data-image="/covers/12.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/11/22/Modern-C++-Programming-Cookbook-Notes/Modern-C++-Programming-Cookbook-Notes-7/"><img class="next_cover lazyload" data-src="/covers/33.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Modern C++ Programming Cookbook Notes 7: Stream, Robustness and Idioms</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a87be25f987639da0355',
  clientSecret: '2d8818b819ff046e4945c16e4e5830337af60ff6',
  repo: 'gusabary.github.io',
  owner: 'Gusabary',
  admin: 'Gusabary',
  id: md5(decodeURI(location.pathname)),
  language: 'en , zh-CN , zh-TW',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Gusabary</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Nature's blessings upon you!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>