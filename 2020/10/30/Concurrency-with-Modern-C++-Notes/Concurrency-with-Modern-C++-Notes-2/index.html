<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Concurrency with Modern C++ Notes 2: Multithreading | Gusabary</title><meta name="description" content="Concurrency with Modern C++ Notes 2: Multithreading"><meta name="keywords" content="C++,Concurrency with Modern C++"><meta name="author" content="Gusabary"><meta name="copyright" content="Gusabary"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Concurrency with Modern C++ Notes 2: Multithreading"><meta name="twitter:description" content="Concurrency with Modern C++ Notes 2: Multithreading"><meta name="twitter:image" content="http://gusabary.cn/covers/26.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Concurrency with Modern C++ Notes 2: Multithreading"><meta property="og:url" content="http://gusabary.cn/2020/10/30/Concurrency-with-Modern-C++-Notes/Concurrency-with-Modern-C++-Notes-2/"><meta property="og:site_name" content="Gusabary"><meta property="og:description" content="Concurrency with Modern C++ Notes 2: Multithreading"><meta property="og:image" content="http://gusabary.cn/covers/26.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://gusabary.cn/2020/10/30/Concurrency-with-Modern-C++-Notes/Concurrency-with-Modern-C++-Notes-2/"><link rel="prev" title="Modern C++ Programming Cookbook Notes 1: Learning Modern Core Language Features" href="http://gusabary.cn/2020/11/04/Modern-C++-Programming-Cookbook-Notes/Modern-C++-Programming-Cookbook-Notes-1/"><link rel="next" title="Concurrency with Modern C++ Notes 1: Memory Model" href="http://gusabary.cn/2020/10/29/Concurrency-with-Modern-C++-Notes/Concurrency-with-Modern-C++-Notes-1/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Gusabary</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-2-Multithreading"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Chapter 2  Multithreading</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-Threads"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">2.1  Threads</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-Shared-Data"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2.2  Shared Data</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-Thread-Local-Data"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">2.3  Thread-Local Data</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4-Condition-Variables"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">2.4  Condition Variables</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5-Tasks"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2.5  Tasks</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Link"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Link</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-2-Multithreading"><span class="toc-number">1.</span> <span class="toc-text">Chapter 2  Multithreading</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Threads"><span class="toc-number">1.1.</span> <span class="toc-text">2.1  Threads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Shared-Data"><span class="toc-number">1.2.</span> <span class="toc-text">2.2  Shared Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Thread-Local-Data"><span class="toc-number">1.3.</span> <span class="toc-text">2.3  Thread-Local Data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Condition-Variables"><span class="toc-number">1.4.</span> <span class="toc-text">2.4  Condition Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Tasks"><span class="toc-number">1.5.</span> <span class="toc-text">2.5  Tasks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Link"><span class="toc-number">2.</span> <span class="toc-text">Link</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/covers/26.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Concurrency with Modern C++ Notes 2: Multithreading</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-10-30<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-10-30</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="Chapter-2-Multithreading"><a href="#Chapter-2-Multithreading" class="headerlink" title="Chapter 2  Multithreading"></a>Chapter 2  Multithreading</h2><h3 id="2-1-Threads"><a href="#2-1-Threads" class="headerlink" title="2.1  Threads"></a>2.1  Threads</h3><ul>
<li><p><code>std::thread</code> has no copy operations. It accepts a callable as work package, whose return value is ignored.</p>
<p>The creator of <code>std::thread</code> should manage its lifecycle, i.e. it should invoke <code>join()</code> to wait the thread ends or <code>detach()</code> to detach itself from the thread. Actually, before <code>join()</code> or <code>detach()</code> is called, the thread is <em>joinable</em>, and the destructor of a joinable thread throws a <code>std::terminate</code> exception.</p>
<p>One thing worth noting is that detached threads will terminate with the executable binary, which means when the main thread exits, all detached threads will also exit even if their work package hasn’t fully done. Take below for an example:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">([] &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;)</span></span>;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// if this line is commented, "hello" may not be printed</span></span><br><span class="line">    <span class="comment">// std::this_thread::sleep_for(std::chrono::milliseconds(1));</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>std::thread</code>‘s constructor is a variadic template. So if you want to pass argument by reference, it needs to use <code>std::ref</code> even if the parameter of the callable as work package is reference.</p>
</li>
<li><p>We can use <code>swap()</code> method to swap (in a move way) two threads.</p>
</li>
<li><p>We can use <code>std::thread::native_handle()</code> to get information about system-specific implementation of <code>std::thread</code>.</p>
</li>
</ul>
<h3 id="2-2-Shared-Data"><a href="#2-2-Shared-Data" class="headerlink" title="2.2  Shared Data"></a>2.2  Shared Data</h3><ul>
<li><p>Insertion to and extracting from global stream objects (like <code>std::cin</code>, <code>std::cout</code>) are thread-safe, although the output statements can interleave. In another word, writing to <code>std::cout</code> is not a data race but a race condition (of output statements).</p>
</li>
<li><p>There are many kinds of mutex. Most basically, there is a <code>std::mutex</code>, which supports <code>lock()</code>, <code>try_lock()</code> and <code>unlock()</code>. Then it’s <code>std::recursive_mutex</code>, which can lock many times and stay locked until unlock as many times as it has locked. There also <code>std::timed_mutex</code> and <code>std::recursive_timed_mutex</code> which support <code>try_lock_for()</code> and <code>try_lock_until()</code>.</p>
<p><code>std::shared_timed_mutex</code> (since C++14) and <code>std::shared_mutex</code> (since C++17) also provide a series of methods of <code>*_lock_shared_*</code>, which can be used to implement read-write lock (introduced later).</p>
</li>
<li><p>Cool, right? Since we have mutex we can write some code like this:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line">m.lock();</span><br><span class="line">sharedVariable = getVar();</span><br><span class="line">m.unlock();</span><br></pre></td></tr></table></figure></div>

<p>However, it’s quite prone to deadlock due to the <code>getVar()</code>: what if it throws an exception? what if it also acquire the mutex <code>m</code>? what if it’s a library function and someday gets upgraded with some code you never know?</p>
<p>So apparently, it’s better to avoid calling functions while holding a lock.</p>
</li>
<li><p>To solve deadlocks, we can use <em>locks</em>: <code>std::lock_guard</code>, <code>std::unique_lock</code>, <code>std::shared_lock</code>(since C++14) and <code>std::scoped_lock</code> (since C++17).</p>
<p>First let’s look at <code>std::lock_guard</code>. Maybe you’ve heard about <em>RAII</em>. Yep, that’s the mechanism <code>std::lock_guard</code> uses to solve the deadlock which happens when you forget to release the lock (maybe because an exception is thrown):</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  	<span class="built_in">std</span>::mutex m;</span><br><span class="line">  	<span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lockGuard</span><span class="params">(m)</span></span>;</span><br><span class="line">  	<span class="comment">/* critical section */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Then it’s <code>std::unique_lock</code>, which is stronger but more expensive than <code>std::lock_guard</code>. For example it enables you to create a lock without locking the mutex immediately, recursively lock a mutex and so on.</p>
<p>One thing worth noting is that we can use <code>std::lock()</code>, which is a variadic template, to lock multiple mutexes in an atomic step:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex a, b;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard1</span><span class="params">(a, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">guard2</span><span class="params">(b, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::lock(guard1, guard2);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>Here comes <code>std::shared_lock</code>, which behaves like <code>std::unique_lock</code>, except in the condition that it’s used with <code>std::shared_mutex</code> or <code>std::shared_timed_mutex</code> (which are introduced before). It can be used to implement a read-write lock. To be more precise, <code>std::lock_guard&lt;std::shared_mutex&gt;</code> or <code>std::unique_lock&lt;std::shared_mutex&gt;</code> is used for write lock while <code>std::shared_lock&lt;std::shared_mutex&gt;</code> is used for read lock. This is essentially because <code>std::shared_mutex</code> supports both <code>*_lock_*</code> and <code>*_lock_shared_*</code> methods which invoked separately by <code>std::unique_lock</code> and <code>std::shared_lock</code>.</p>
</li>
<li><p>Finally it’s <code>std::scoped_lock</code>. Still remember the <code>std::lock()</code> function? Yep, they are very similar. Actually, <code>std::scoped_lock</code>‘s constructor is a variadic template, which 1) behaves like a <code>std::lock_guard</code> when there is just one mutex argument, 2) invokes <code>std::lock()</code> when there are multiple mutex arguments.</p>
<p>In another word, <code>std::scoped_lock</code> can lock many mutexes in an atomic step.</p>
</li>
<li><p>Sometimes we need to ensure that objects are initialized in a thread-safe way (imagine the singleton design pattern), typically there are three ways to do that (ok, if you count in initializing objects in main thread before creation of child threads, there are four).</p>
<p>The first is use <code>constexpr</code> to initialize objects as constant expressions in compile time. Note that an object can be annotated as <code>constexpr</code> only if its class satisfies some restrictions. For example, it cannot have virtual base class and virtual methods; it’s constructor must be empty (except for the initialization list) and const expression; its base classes and non-static members should all be initialized (in the initialization list) and so on.</p>
</li>
<li><p>The second is to use <code>std::call_once</code> and <code>std::once_flag</code>. The semantic is easy to understand: <code>std::call_once</code> is a function, which accepts two parameters, the first one is a <code>std::once_flag</code> and the second one is a callable. We can invoke <code>std::call_once</code> many times with the same <code>std::once_flag</code>, and exactly one callable of them will be executed exactly once.</p>
<p>Use this to implement singleton:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::once_flag initInstanceFlag;</span><br><span class="line">    <span class="keyword">static</span> MySingleton* instance;</span><br><span class="line">    MySingleton() = <span class="keyword">default</span>;</span><br><span class="line">    ~MySingleton() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MySingleton(<span class="keyword">const</span> MySingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MySingleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MySingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> MySingleton* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::call_once(initInstanceFlag, MySingleton::initSingleton);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> MySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MySingleton* MySingleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::once_flag MySingleton::initInstanceFlag;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>The third is static variables with block scope. Those static variables are created exactly once and lazily, which means they won’t get created until used. And since C++11, there is another guarantee: static variables with block scope are created in a thread-safe way (but it seems to be dependent on compiler implementations). So we can write a singleton class like this:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MySingleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> MySingleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MySingleton() = <span class="keyword">default</span>;</span><br><span class="line">    ~MySingleton() = <span class="keyword">default</span>;</span><br><span class="line">    MySingleton(<span class="keyword">const</span> MySingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MySingleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MySingleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="2-3-Thread-Local-Data"><a href="#2-3-Thread-Local-Data" class="headerlink" title="2.3  Thread-Local Data"></a>2.3  Thread-Local Data</h3><ul>
<li><p>Actually I’ve never heard about the <code>thread_local</code> keyword in C++ before. This keyword acts like <code>static</code>:</p>
<ul>
<li><p>if it qualifies a variable in namespace scope or as static class member, the variable will be created before its first usage:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> A::x;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>if it qualifies a variable in a function, the variable will be created at its first usage:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ul>
</li>
<li><p>The difference between <code>thread_local</code> and <code>static</code> is that variables qualified by the former have lifecycle bound to the thread which created them while ones qualified by the latter have lifecycle bound to the main thread.</p>
</li>
</ul>
<h3 id="2-4-Condition-Variables"><a href="#2-4-Condition-Variables" class="headerlink" title="2.4  Condition Variables"></a>2.4  Condition Variables</h3><ul>
<li><p><code>std::condition_variable</code> is literally a condition variable, which provides methods like <code>notify_one()</code>, <code>notify_all()</code>, <code>wait()</code> and so on.</p>
<p>The <code>wait()</code> method usually accepts two parameters, the first one is a <code>std::unique_lock</code> and the second one is a callable called <em>Predict</em>. Let’s take a closer look.</p>
</li>
<li><p>Why does the lock need to be a <code>std::unique_lock</code> instead of <code>std::lock_guard</code>? Be aware that when <code>wait()</code> is invoked, the lock gets released and actually we will see later that the lock gets acquired and released repeatedly, so we need a <code>std::unique_lock</code> instead of a one-time <code>std::lock_guard</code>.</p>
</li>
<li><p>Then what’s the role of <em>Predict</em>? When talking about condition variables, we should be clear about these two phenomena: <em>lost wakeup</em> and <em>spurious wakeup</em>. Lost wakeup is to say the notify could come before the wait while spurious wakeup is to say the thread in waiting state could wake up itself even if there is no notification. Predict is to solve these problems:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">condVar.wait(lck, []&#123; <span class="keyword">return</span> dataReady; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// equivalent to</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(mutex_)</span></span>;</span><br><span class="line"><span class="keyword">while</span> ( ![]&#123; <span class="keyword">return</span> dataReady; &#125;() ) &#123;</span><br><span class="line">    condVar.wait(lck);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>The <code>dataReady</code> in the above example is a flag used to synchronize the notification. It doesn’t need to be an atomic, but it must be protected by a mutex (we can use <code>std::lock_guard</code> here):</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lck</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">	dataReady = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">condVar.notify_one();</span><br></pre></td></tr></table></figure></div>

<p>If not protected by a mutex, it may happen that the modification to <code>dataReady</code> and notification are executed <strong>rightly after the Predict check and before the condition variable wait</strong>, which will cause the thread to wait forever.</p>
</li>
</ul>
<h3 id="2-5-Tasks"><a href="#2-5-Tasks" class="headerlink" title="2.5  Tasks"></a>2.5  Tasks</h3><ul>
<li><p>Task is also a mechanism to perform work package asynchronously. Different from threads, tasks are not necessarily in another thread. Actually, the workflow of tasks is to perform the work package and produce the promise, and the result can be synchronized through a future.</p>
</li>
<li><p><code>std::async</code> is a simple way to create a task, and its return value is the future of the task. Other than the work package, we can pass in a policy when invoking <code>std::async</code>, which can be <code>std::launch::deferred</code> for lazy evaluation or <code>std::launch::async</code> for eager evaluation.</p>
<p>Also, it’s not necessary to assign the return value of <code>std::async</code> to a variable. In another word, we can just invoke it and dismiss its return value, in which case the future is called <em>fire and forget future</em>:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fire and forget"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;);</span><br></pre></td></tr></table></figure></div>

<p>Note that we need <code>std::launch::async</code> to make sure a eager evaluation because we have no future to wait on.</p>
<p>However, there is an inconspicuous drawback here: future waits on its destructor until its promise is done. In the case of fire and forget futures, the futures are temporary, whose destructor gets invoked immediately after the <code>std::async</code> creating them. So the async is actually, umm, a fake one:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [] &#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first thread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* waiting for the promise done */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, [] &#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));  </span><br><span class="line">    <span class="comment">// get printed after 6 seconds instead of 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"second thread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>std::package_task</code> is another way to create a task which is not executed immediately. Actually its usage typically consists of four steps:</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. create the task</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span>&gt; <span class="title">sumTask</span><span class="params">([](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a + b; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. assign to a future</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; sumResult = sumTask.get_future();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. do the execution</span></span><br><span class="line">sumTask(<span class="number">2000</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. wait on the future</span></span><br><span class="line">sumResult.<span class="built_in">get</span>();</span><br></pre></td></tr></table></figure></div>

<p>To my understanding, <code>std::async</code> combines the first three steps together and the task created by it cannot accept parameters.</p>
<p>If we want to execute the task and wait on the future multiple times, it needs to invoke the <code>reset()</code> method of <code>std::packaged_task</code>.</p>
</li>
<li><p><code>std::promise</code> can set not only a value but also an exception with <code>set_exception()</code> method. If that’s the case, the corresponding future will encounter the exception when invoking the <code>get()</code> method.</p>
<p><code>std::future</code> can use <code>valid()</code> method to check if the shared state is available and use <code>wait_for()</code> or <code>wait_until()</code> to wait with a timeout. The latter returns a <code>std::future_status</code>, which is a scoped enum class with enumerations of <code>deferred</code>, <code>ready</code> and <code>timeout</code> (to be frank, I don’t know what <code>deferred</code> means)</p>
</li>
<li><p>Different from <code>std::future</code>, <code>std::shared_future</code> is copyable and can be queried multiple times.</p>
<p>We have two ways to get a <code>std::shared_future</code>: <code>get_future()</code> method of <code>std::promise</code> and <code>share()</code> method of <code>std::future</code>. Note that after invocation of <code>share()</code>, the <code>valid()</code> method of <code>std::future</code> shall return false.</p>
</li>
<li><p>I think it needs a clarification about <em>available shared state</em> here. We know <code>valid()</code> method of <code>std::future</code> or <code>std::shared_future</code> indicates whether an available shared state exists. In another word, if it returns true, <code>wait()</code> method can be called without exception; if it returns false, <code>wait()</code> will result in an exception.</p>
<p>For initialized <code>std::future</code>, before the first <code>get()</code>, <code>wait()</code> or <code>share()</code>, the <code>valid()</code> will return true; while after that, <code>valid()</code> shall return false. And for initialized <code>std::shared_future</code>, <code>valid()</code> shall always return true, which means you can always query on a <code>std::shared_future</code>.</p>
</li>
<li><p>If the callable used in <code>std::async</code> and <code>std::packaged_task</code> throws an exception, it will be stored in the shared state (just like what <code>set_exception()</code> method of <code>std::promise</code> does), and rethrown when queried by future. One thing worth noting is that <code>std::current_exception()</code> can be used to get the caught exception in the catch block.</p>
</li>
<li><p><code>void</code> as the template argument, <code>std::promise</code> and <code>std::future</code> could be used for notification and synchronization. Compared to condition variables, the task-based notification mechanism could not perform synchronization multiple times (since <code>std::promise</code> could only set its value once and <code>std::future</code> could only query once) but needn’t a shared variable or mutex and isn’t prone to lost wakeup or spurious wakeup.</p>
<p>So the conclusion is that if multiple synchronization is not needed, task-based notification mechanism is preferred.</p>
</li>
</ul>
<h2 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h2><ul>
<li><a href="https://subscription.packtpub.com/book/programming/9781839211027/5" target="_blank" rel="noopener">https://subscription.packtpub.com/book/programming/9781839211027/5</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Gusabary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://gusabary.cn/2020/10/30/Concurrency-with-Modern-C++-Notes/Concurrency-with-Modern-C++-Notes-2/">http://gusabary.cn/2020/10/30/Concurrency-with-Modern-C++-Notes/Concurrency-with-Modern-C++-Notes-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++    </a><a class="post-meta__tags" href="/tags/Concurrency-with-Modern-C/">Concurrency with Modern C++    </a></div><div class="post_share"><div class="social-share" data-image="/covers/26.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/11/04/Modern-C++-Programming-Cookbook-Notes/Modern-C++-Programming-Cookbook-Notes-1/"><img class="prev_cover lazyload" data-src="/covers/3.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>Modern C++ Programming Cookbook Notes 1: Learning Modern Core Language Features</span></div></a></div><div class="next-post pull_right"><a href="/2020/10/29/Concurrency-with-Modern-C++-Notes/Concurrency-with-Modern-C++-Notes-1/"><img class="next_cover lazyload" data-src="/covers/44.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Concurrency with Modern C++ Notes 1: Memory Model</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a87be25f987639da0355',
  clientSecret: '2d8818b819ff046e4945c16e4e5830337af60ff6',
  repo: 'gusabary.github.io',
  owner: 'Gusabary',
  admin: 'Gusabary',
  id: md5(decodeURI(location.pathname)),
  language: 'en , zh-CN , zh-TW',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Gusabary</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Nature's blessings upon you!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>