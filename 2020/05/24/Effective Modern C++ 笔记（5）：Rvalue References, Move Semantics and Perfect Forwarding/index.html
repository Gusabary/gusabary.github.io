<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding | Gusabary</title><meta name="description" content="Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding"><meta name="keywords" content="C++,C++11,C++14,Effective Modern C++"><meta name="author" content="Gusabary"><meta name="copyright" content="Gusabary"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/avatar.jpeg"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding"><meta name="twitter:description" content="Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding"><meta name="twitter:image" content="http://gusabary.cn/covers/29.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding"><meta property="og:url" content="http://gusabary.cn/2020/05/24/Effective%20Modern%20C++%20%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9ARvalue%20References,%20Move%20Semantics%20and%20Perfect%20Forwarding/"><meta property="og:site_name" content="Gusabary"><meta property="og:description" content="Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding"><meta property="og:image" content="http://gusabary.cn/covers/29.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://gusabary.cn/2020/05/24/Effective%20Modern%20C++%20%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9ARvalue%20References,%20Move%20Semantics%20and%20Perfect%20Forwarding/"><link rel="next" title="Effective Modern C++ 笔记（4）：Smart Pointers" href="http://gusabary.cn/2020/05/23/Effective%20Modern%20C++%20%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9ASmart%20Pointers/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Gusabary</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">19</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">Catalog</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Chapter-5-Rvalue-References-Move-Semantics-and-Perfect-Forwarding"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Chapter 5  Rvalue References, Move Semantics and Perfect Forwarding</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-23-Understand-std-move-and-std-forward"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">Item 23  Understand std::move and std::forward</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-24-Distinguish-universal-reference-from-rvalue-reference"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">Item 24  Distinguish universal reference from rvalue reference</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-25-Use-std-move-on-rvalue-references-std-forward-on-universal-references"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">Item 25  Use std::move on rvalue references, std::forward on universal references</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-26-Avoid-overloading-on-universal-references"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">Item 26  Avoid overloading on universal references</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-27-Familiarize-yourself-with-alternatives-to-overloading-on-universal-references"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">Item 27  Familiarize yourself with alternatives to overloading on universal references</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-28-Understand-reference-collapsing"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">Item 28  Understand reference collapsing</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-29-Assume-that-move-operations-are-not-present-not-cheap-and-not-used"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">Item 29  Assume that move operations are not present, not cheap and not used</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Item-30-Familiarize-yourself-with-perfect-forwarding-failure-cases"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">Item 30  Familiarize yourself with perfect forwarding failure cases</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Reference"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">Reference</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-5-Rvalue-References-Move-Semantics-and-Perfect-Forwarding"><span class="toc-number">1.</span> <span class="toc-text">Chapter 5  Rvalue References, Move Semantics and Perfect Forwarding</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-23-Understand-std-move-and-std-forward"><span class="toc-number">1.1.</span> <span class="toc-text">Item 23  Understand std::move and std::forward</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-24-Distinguish-universal-reference-from-rvalue-reference"><span class="toc-number">1.2.</span> <span class="toc-text">Item 24  Distinguish universal reference from rvalue reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-25-Use-std-move-on-rvalue-references-std-forward-on-universal-references"><span class="toc-number">1.3.</span> <span class="toc-text">Item 25  Use std::move on rvalue references, std::forward on universal references</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-26-Avoid-overloading-on-universal-references"><span class="toc-number">1.4.</span> <span class="toc-text">Item 26  Avoid overloading on universal references</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-27-Familiarize-yourself-with-alternatives-to-overloading-on-universal-references"><span class="toc-number">1.5.</span> <span class="toc-text">Item 27  Familiarize yourself with alternatives to overloading on universal references</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-28-Understand-reference-collapsing"><span class="toc-number">1.6.</span> <span class="toc-text">Item 28  Understand reference collapsing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-29-Assume-that-move-operations-are-not-present-not-cheap-and-not-used"><span class="toc-number">1.7.</span> <span class="toc-text">Item 29  Assume that move operations are not present, not cheap and not used</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Item-30-Familiarize-yourself-with-perfect-forwarding-failure-cases"><span class="toc-number">1.8.</span> <span class="toc-text">Item 30  Familiarize yourself with perfect forwarding failure cases</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">2.</span> <span class="toc-text">Reference</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/covers/29.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">Effective Modern C++ 笔记（5）：Rvalue References, Move Semantics and Perfect Forwarding</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> Created 2020-05-24<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> Updated 2020-05-24</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>Post View:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="Chapter-5-Rvalue-References-Move-Semantics-and-Perfect-Forwarding"><a href="#Chapter-5-Rvalue-References-Move-Semantics-and-Perfect-Forwarding" class="headerlink" title="Chapter 5  Rvalue References, Move Semantics and Perfect Forwarding"></a>Chapter 5  Rvalue References, Move Semantics and Perfect Forwarding</h2><h3 id="Item-23-Understand-std-move-and-std-forward"><a href="#Item-23-Understand-std-move-and-std-forward" class="headerlink" title="Item 23  Understand std::move and std::forward"></a>Item 23  Understand std::move and std::forward</h3><ul>
<li><p><code>std::move</code> 和 <code>std::forward</code> 在运行时刻不做任何事（它们不会生成哪怕一个字节的可执行代码），只是在编译时刻转换参数的左右值属性：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">move</span><span class="params">(T&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">using</span> ReturnType = <span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ReturnType&gt;(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意：作为返回值的右值引用是右值！</p>
</li>
<li><p><code>move</code> 无条件地将参数转换成右值，而 <code>forward</code> 可以根据模板参数来决定是否将参数转换成右值。尽管用 <code>forward</code> 也可以实现 <code>move</code> 的功能，但是需要多指定一个模板参数，并且语义上也不太合适：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="built_in">std</span>::forward&lt;A&gt;(a);</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="Item-24-Distinguish-universal-reference-from-rvalue-reference"><a href="#Item-24-Distinguish-universal-reference-from-rvalue-reference" class="headerlink" title="Item 24  Distinguish universal reference from rvalue reference"></a>Item 24  Distinguish universal reference from rvalue reference</h3><ul>
<li><p>universal reference 需要满足两个条件：有形如 <code>T&amp;&amp;</code> 的类型以及发生了类型推断。</p>
<ul>
<li><p>仅发生类型推断但没有 <code>T&amp;&amp;</code> 类型的情况：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>;		<span class="comment">// rvalue reference</span></span><br></pre></td></tr></table></figure></div>

<p>注意必须是严格的 <code>T&amp;&amp;</code>（当然不一定非得是 <code>T</code>），多一个 <code>const</code> 也不行：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>;	<span class="comment">// rvalue reference</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>仅有 <code>T&amp;&amp;</code> 类型但没有发生类型推断的情况：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Allocator</span> = <span class="title">allocator</span>&lt;T&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span></span>;		<span class="comment">// rvalue reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>该情况中，实际调到 <code>push_back</code> 前类模板已经被实例化了，所以 <code>T</code> 已经是一个具体的类型了，不会发生类型推断。</p>
</li>
</ul>
<p><code>T&amp;&amp;</code> 也可以是 <code>auto&amp;&amp;</code>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;  <span class="comment">// universal reference</span></span><br></pre></td></tr></table></figure></div>

<p>这在 C++14 的 lambda 表达式中尤其有用：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> timeFuncInvocation = [](<span class="keyword">auto</span>&amp;&amp; func, <span class="keyword">auto</span>&amp;&amp;... params) &#123;  <span class="comment">// universal reference</span></span><br><span class="line"> 	<span class="comment">// start timer</span></span><br><span class="line"> 	<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(func)&gt;(func)(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(params)&gt;(params)...);</span><br><span class="line"> 	<span class="comment">// stop timer and record elapsed time</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>universal reference 表现成 lvalue reference 还是 rvalue reference 由初始化表达式是左值还是右值来决定：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">// param is a universal reference</span></span><br><span class="line"></span><br><span class="line">Widget w;</span><br><span class="line">f(w); 			  <span class="comment">// lvalue passed to f; param's type is Widget&amp;  (lvalue reference)</span></span><br><span class="line">f(<span class="built_in">std</span>::<span class="built_in">move</span>(w));  <span class="comment">// rvalue passed to f; param's type is Widget&amp;&amp; (rvalue reference)</span></span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="Item-25-Use-std-move-on-rvalue-references-std-forward-on-universal-references"><a href="#Item-25-Use-std-move-on-rvalue-references-std-forward-on-universal-references" class="headerlink" title="Item 25  Use std::move on rvalue references, std::forward on universal references"></a>Item 25  Use std::move on rvalue references, std::forward on universal references</h3><ul>
<li><p>对于函数入参，将 <code>move</code> 作用于 rvalue reference，将 <code>forward</code> 作用于 universal reference，需要注意的是如果多次使用该入参，则只能将 <code>move</code> 或 <code>forward</code> 作用在最后一次上：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setSignText</span><span class="params">(T&amp;&amp; <span class="built_in">text</span>)</span> </span>&#123;</span><br><span class="line"> 	sign.setText(<span class="built_in">text</span>);</span><br><span class="line"> 	<span class="keyword">auto</span> now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">	signHistory.add(now, <span class="built_in">std</span>::forward&lt;T&gt;(<span class="built_in">text</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当然，这里说的 “最后一次” 也可以是返回值（如果函数的返回值是 return by value 的话）：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Matrix <span class="keyword">operator</span>+(Matrix&amp;&amp; lhs, <span class="keyword">const</span> Matrix&amp; rhs) &#123;</span><br><span class="line"> 	lhs += rhs;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">move</span>(lhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样做的好处在于省去一次 copy 的开销。</p>
</li>
<li><p>但是将 <code>move</code> 作用于返回值这一操作对于 local 对象来说，情况有所不同。首先需要明白为什么要将 <code>move</code> 作用于返回值？因为想省下一次 copy 操作的开销。那么返回一个 local 对象真的会 copy 吗？其实大部分情况下是不会的，因为编译器做了 RVO（返回值优化），即直接在存放函数返回值的内存位置处构造这个 local 对象：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	Widget w;  <span class="comment">// 构造在存放函数返回值的内存位置，而非存放普通 local 对象的位置</span></span><br><span class="line"> 	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>所以即使不加 <code>move</code>，编译器也不会 copy。相反，如果加了 <code>move</code>，编译器将不会进行 RVO，因为 RVO 需要满足两个条件：local 对象类型要和返回值类型一样且 local 对象就是被返回的对象。而被返回的对象（<code>std::move(w)</code>）是 <code>w</code> 的引用，并非 <code>w</code> 本身，所以不满足 RVO 的条件。</p>
<p>那有的人也许会说，我加了 <code>move</code> 虽然放弃了 RVO 的机会（这里说是 “机会” 是因为不是说不加 <code>move</code> 就一定会 RVO，仍然有很多其他情况阻止编译器做 RVO，比如有多处返回值返回不同的 local 变量），但至少保证了不会 copy。这个观点也是不对的，因为如果满足 RVO 的条件而编译器由于种种原因没有做 RVO 的话，它也会将返回值作为右值来处理，即看上去像是编译器帮你加了 <code>move</code> 一样。</p>
<p>总结一下就是，当函数满足 RVO 的条件时，不要将 <code>move</code> 作用于返回值。因为如果确实做了 RVO，那就白白多了一次 move 操作；而就算没有做 RVO，编译器也会将其当做右值处理，手动加上 <code>move</code> 并没有任何优化。</p>
</li>
<li><p>同样地，对于返回值是值传递进来的参数的情况，编译器也会将其当做右值处理（这种情况做不了 RVO），不用程序员加上 <code>move</code>：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">(Widget w)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="Item-26-Avoid-overloading-on-universal-references"><a href="#Item-26-Avoid-overloading-on-universal-references" class="headerlink" title="Item 26  Avoid overloading on universal references"></a>Item 26  Avoid overloading on universal references</h3><ul>
<li><p>尽量避免对 universal reference 进行重载：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(<span class="keyword">int</span> idx)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，只要参数类型不是 int，对 <code>logAndAdd</code> 的调用都会被有 universal reference 的版本捕获，因为它可以实例化出一个完美匹配的模板函数。在 C++ 重载函数的版本选择中，类型能完美匹配的优于需要转型的，如果类型都能完美匹配，那么非模板函数优于实例化出来的模板函数。</p>
</li>
<li><p>除此以外，当类的构造中含有 universal reference 时，情况会变得更糟。它会捕获所有非常量拷贝构造（编译器自动生成的拷贝构造参数具有 <code>const</code>，不能算完美匹配了），还会捕获所有来自子类的拷贝构造（子类的类型被父类的拷贝构造接受需要转型）</p>
</li>
</ul>
<h3 id="Item-27-Familiarize-yourself-with-alternatives-to-overloading-on-universal-references"><a href="#Item-27-Familiarize-yourself-with-alternatives-to-overloading-on-universal-references" class="headerlink" title="Item 27  Familiarize yourself with alternatives to overloading on universal references"></a>Item 27  Familiarize yourself with alternatives to overloading on universal references</h3><p>如果不得不利用重载 universal reference 提供的功能，有几种方式可以避免它带来的问题：</p>
<ul>
<li>不重载，用不同名的函数。</li>
<li>不使用 universal reference，可以使用常量左值引用或值传递。</li>
</ul>
<p>（以上两种方法都不是很好）</p>
<ul>
<li><p>Tag Dispatch。重载 universal reference 带来的问题就是选择重载版本时，它往往会捕获到比我们想象的多得多的调用，那只要解决这个问题就可以了。注意到选择重载版本是以参数类型为依据的，universal reference 只是其中一个参数，我们可以使用另一个参数（tag）来决定调用（dispatch）哪个版本：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang"></div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">logAndAdd</span><span class="params">(T&amp;&amp; name)</span> </span>&#123;</span><br><span class="line"> 	logAndAddImpl(</span><br><span class="line">    	<span class="built_in">std</span>::forward&lt;T&gt;(name),</span><br><span class="line"> 		<span class="built_in">std</span>::is_integral&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&gt;()</span><br><span class="line">        <span class="comment">// 使用 remove_reference 是因为 int&amp; 不是 integral type</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">void logAndAddImpl(T&amp;&amp; name, std::false_type)；</span><br><span class="line"></span><br><span class="line">void logAndAddImpl(int idx, std::true_type)；</span><br></pre></td></tr></table></figure></div>

<p><code>std::true_type</code> 和 <code>std::false_type</code> 是编译时的 bool 类型。选择重载版本时它们能 “屏蔽” universal reference 的完美匹配（就好比是在 “完美匹配 + 完美不匹配” 和 “需要转型 + 完美匹配” 中选一个）。</p>
</li>
<li><p>还有一种方法，用到模板可以在某些条件下被禁用的机制，<code>condition</code> 不满足时，该模板就好像不存在一样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;condition&gt;::type&gt;</span><br></pre></td></tr></table></figure></div>

<p>为了不让 universal reference 捕获到和自定义类型仅 cvr 属性不同的参数、是自定义类型派生类的参数或者 integral type，可以这样指定自定义类型的含有 universal reference 的构造函数：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;</span><br><span class="line">	<span class="keyword">typename</span> T,</span><br><span class="line"> 	<span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt;</span><br><span class="line"> 		!<span class="built_in">std</span>::is_base_of&lt;Person, <span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;T&gt;&gt;::value &amp;&amp;</span><br><span class="line"> 		!<span class="built_in">std</span>::is_integral&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&gt;::value</span><br><span class="line"> 	&gt;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">explicit</span> Person(T&amp;&amp; n) : name(<span class="built_in">std</span>::forward&lt;T&gt;(n)) &#123;&#125;</span><br></pre></td></tr></table></figure></div>

<p>这种方法解决了 Tag Dispatch 的一个问题：即使是含有 universal reference 的构造函数也不能捕获所有调用（还存在其他重载版本，比如默认拷贝构造），所以就没办法作为一个 dispatcher。</p>
</li>
<li><p>universal reference 的确效率很高，但是往往存在易用性上的问题，比如报错信息太隐晦。</p>
</li>
</ul>
<h3 id="Item-28-Understand-reference-collapsing"><a href="#Item-28-Understand-reference-collapsing" class="headerlink" title="Item 28  Understand reference collapsing"></a>Item 28  Understand reference collapsing</h3><p>reference collapsing 是说当编译器生成了一个引用的引用时（程序员是不能定义引用的引用的），会按照以下规则将其折叠成单引用：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; &amp;   -&gt; T&amp;</span><br><span class="line">T&amp; &amp;&amp;  -&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp;  -&gt; T&amp;</span><br><span class="line">T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;</span><br></pre></td></tr></table></figure></div>

<p>有四种情况会发生 reference collapsing：</p>
<ul>
<li><p>模板实例化（universal reference），这也是用的最多的一个情形：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>当实参为左值时，<code>T</code> 推断为左值引用 <code>&amp;</code>，发生 reference collapsing（当实参为右值时，<code>T</code> 被推断为普通类型，没有 reference collapsing）</p>
</li>
<li><p>auto 类型推断（universal reference），如 Item 24 中所述，这也是 universal reference：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp;&amp; w1 = w;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>typedef 和类型别名，上面两种情况是根据参数的左右值属性来推断不同的 <code>T</code> 或 <code>auto</code>，推断的结果有两种：普通类型和左值引用，只有推断为左值引用时才会发生 reference collapsing，但是这种情况（以及下面那种情况）不同，它们没有发生类型推断：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="keyword">typedef</span> T&amp;&amp; RvalueRefToT;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&lt;<span class="keyword">int</span>&amp;&gt; w1;	<span class="comment">// int&amp;</span></span><br><span class="line">Widget&lt;<span class="keyword">int</span>&amp;&amp;&gt; w2;	<span class="comment">// int&amp;&amp;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>decltype，和第三种情况类似：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(a) &amp;&amp;b;</span><br></pre></td></tr></table></figure></div>

</li>
</ul>
<h3 id="Item-29-Assume-that-move-operations-are-not-present-not-cheap-and-not-used"><a href="#Item-29-Assume-that-move-operations-are-not-present-not-cheap-and-not-used" class="headerlink" title="Item 29  Assume that move operations are not present, not cheap and not used"></a>Item 29  Assume that move operations are not present, not cheap and not used</h3><p>move 操作并非总是优于 copy 操作，例如：</p>
<ul>
<li>有些类不支持 move 操作；</li>
<li>对于小对象，copy 操作有时也会比 move 操作快（比如 <code>std::string</code> 的 SSO，Small String Optimization）；</li>
<li>move 操作会抛出异常，而接口要求 noexcept 时。</li>
</ul>
<h3 id="Item-30-Familiarize-yourself-with-perfect-forwarding-failure-cases"><a href="#Item-30-Familiarize-yourself-with-perfect-forwarding-failure-cases" class="headerlink" title="Item 30  Familiarize yourself with perfect forwarding failure cases"></a>Item 30  Familiarize yourself with perfect forwarding failure cases</h3><p>perfect forwarding 是说有一个转发函数和目标函数，转发函数需要将其接受的参数原封不动地（保留类型，cvr 属性）传递给目标函数。而如果将这些参数传递给转发函数让其转发和直接传递给目标函数得到的行为不一样的话，perferct forwarding 就被认为失败了。</p>
<p>导致 perfect forwarding 失败可能有以下几种情况：</p>
<ul>
<li><p>参数为 braced initializers，即花括号括起来的一组值。将 braced initializers 直接传递给目标函数没有问题，但是转发函数的参数是 universal reference，无法从 braced initializers 推断出类型。但是有一个 trick 可以解决这个问题：先用 braced initializers 初始化一个 <code>auto</code> 的 initializer_list 然后将其传进来。</p>
</li>
<li><p>参数为希望被当成空指针的 0 或 NULL。当转发函数接受到 0 或 NULL 时，会优先转发给目标函数接受 integral type 的重载版本，而非接受指针的重载版本。</p>
</li>
<li><p>参数为未定义的 static const 成员变量。需要先明确一下，“定义” 成员变量是写在类外的，“声明” 成员变量才是类内的：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> 	<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> MinVals = <span class="number">28</span>;  <span class="comment">// declaration</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> Widget::MinVals;  <span class="comment">// definition</span></span><br></pre></td></tr></table></figure></div>

<p>如果不对未定义的 static const 成员变量取地址，那不定义没有什么问题，但是作为转发函数的参数，需要引用这个成员变量，而对编译器生成的代码来说，引用和指针通常没什么区别。即不定义就不占内存，就没有地址，就没办法引用。</p>
</li>
<li><p>参数为有重载版本的函数名或者函数模板。将函数名或函数模板直接传递给目标函数时，可以通过目标函数的参数类型决定用哪个重载版本或模板实例，但是转发函数的参数类型是 universal reference，没有办法选择重载版本或模板实例。解决的方法是先将函数名赋值给一个新定义的确定类型的变量，然后将新定义的变量传递进来或者直接将函数名转型成指定的类型。</p>
</li>
<li><p>参数是位域。C++ 不允许非常量引用绑定到位域，因为没法直接修改 bit。解决的方法和之前类似，先用位域初始化一个 <code>auto</code> 变量，然后将这个新定义的变量传递进来。</p>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/kelthuzadx/EffectiveModernCppChinese" target="_blank" rel="noopener">https://github.com/kelthuzadx/EffectiveModernCppChinese</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Gusabary</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://gusabary.cn/2020/05/24/Effective%20Modern%20C++%20%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9ARvalue%20References,%20Move%20Semantics%20and%20Perfect%20Forwarding/">http://gusabary.cn/2020/05/24/Effective%20Modern%20C++%20%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%EF%BC%9ARvalue%20References,%20Move%20Semantics%20and%20Perfect%20Forwarding/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++    </a><a class="post-meta__tags" href="/tags/C-11/">C++11    </a><a class="post-meta__tags" href="/tags/C-14/">C++14    </a><a class="post-meta__tags" href="/tags/Effective-Modern-C/">Effective Modern C++    </a></div><div class="post_share"><div class="social-share" data-image="/covers/29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/23/Effective%20Modern%20C++%20%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%EF%BC%9ASmart%20Pointers/"><img class="next_cover lazyload" data-src="/covers/9.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>Effective Modern C++ 笔记（4）：Smart Pointers</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'a87be25f987639da0355',
  clientSecret: '2d8818b819ff046e4945c16e4e5830337af60ff6',
  repo: 'gusabary.github.io',
  owner: 'Gusabary',
  admin: 'Gusabary',
  id: md5(decodeURI(location.pathname)),
  language: 'en , zh-CN , zh-TW',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Gusabary</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Nature's blessings upon you!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>